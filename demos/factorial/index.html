<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Demo: Factorial in WebAssembly - Hello, Rust!</title>
<meta name="keywords" content="Rust, Rust programming language, rustlang, rust-lang, Mozilla Rust, WebAssembly, wasm">
<link rel="stylesheet" href="/bootstrap.css">
<link rel="stylesheet" href="/style.css">

<link rel="stylesheet" href="/assets/default.min.css">
<script src="/assets/highlight.min.js"></script>

  </head>

  <body class="container">
    <header>
  <ul class="row menu">
    <li class="col-xs-12 col-md-12 deprecation-notice">
        <h2>
            This site is archived and read-only.
            <br />
            Check out the <a href="https://rustwasm.github.io/">Rust and WebAssembly working group</a>.
        </h2>
    </li>
    <li class="col-xs-12 col-md-10">
      <h1><a href="/">Hello, Rust!</a></h1>
      <h3>Rust for the Web</h3>
    </li>

    <li class="col-xs-12 col-md-10">
      <h2><a href="/news/">News</a></h2>
      <h2><a href="/setup/">Setup</a></h2>
      <h2><a href="/demos/">Demos</a></h2>
      <h2><a href="/talks/">Talks</a></h2>
      <h2><a href="/resources/">Resources</a></h2>
    </li>
  </ul>
</header>


    <div class="row code-row">
      <div class="col-md-12">
        <h2>Factorial in WebAssembly</h2>

<p>
  Type a number into the field and the factorial will be calculated.
  JavaScript has no plain integers, all numbers are actually 64-bit floats.
  It thus cannot correctly handle numbers bigger than 53 bits.
  However, in order to handle the factorial of up to 20, we need 64-bit integers.
  By doing the formatting in Rust (and thus WebAssembly) and returning a string,
  we can correctly print the result.
  For values larger than 20 the result is still incorrect.
</p>

<div class="form">
  <input type="text" name="input" id="input" value="17">
</div>
<br />
<span id="number-out">fact(_) = </span>
<span id="output">1</span>


<script src="/demos/bundle.js"></script>
<script>
  window.Module = {}

  fetchAndInstantiate("./factorial.wasm", {})
    .then(mod => {
      Module.fact  = mod.exports.fact;
      Module.alloc = mod.exports.alloc;
      Module.dealloc_str = mod.exports.dealloc_str;
      Module.memory = mod.exports.memory;
      Module.fact_str = function(n) {
        let outptr = mod.exports.fact_str(n);
        let result = copyCStr(Module, outptr);
        return result;
      }

      var input = document.getElementById("input");
      var output = document.getElementById("output");
      var number_out = document.getElementById("number-out");
      function calcFact() {
        value = input.value|0;
        number_out.innerText = "fact("+value+") = ";
        if (value < 0) {
            output.innerText = "[Value too small.]"
            return;
        }
        output.innerText = Module.fact_str(value);
      }
      calcFact()

      input.addEventListener("keyup", calcFact);
    });
</script>

<hr />

<h2>The Code</h2>

<p>
  The Rust code implements a simple <code>fact</code> function
  as well as a function formatting the 64-bit integer to a string called <code>fact_str</code>.
</p>
<p>
  <a href="./factorial.rs">Download factorial.rs</a>
  <br />
  <a href="./factorial.wat">Download factorial.wat (WebAssembly text format)</a>
</p>

<pre><code class="rust">fn main() {}

#[no_mangle]
pub extern "C" fn fact(mut n: u32) -> u64 {
    let n = n as u64;
    let mut result = 1;
    while n > 0 {
        result = result * n;
        n = n - 1;
    }
    result
}

#[no_mangle]
pub extern "C" fn fact_str(n: u32) -> *mut c_char {
    let res = fact(n);
    let s = format!("{}", res);
    let s = CString::new(s).unwrap();
    s.into_raw()
}
</code></pre>

<p>
  The JavaScript code loads the WebAssembly module and has access to the exported function.
  However it can't call the <code>fact</code> function,
  as it 64-bit integers can't be passed back to JavaScript.
  We therefore have to call the formatting function instead and extract the string.
  The helper function <code>copyCStr</code> is defined in
  <a href="/demos/bundle.js"><code>bundle.js</code></a>.
</p>

<pre><code class="javascript">window.Module = {};
fetchAndInstantiate("./factorial.wasm", {})
.then(mod => {
  Module.fact  = mod.exports.fact;
  Module.alloc = mod.exports.alloc;
  Module.dealloc_str = mod.exports.dealloc_str;
  Module.memory = mod.exports.memory;
  Module.fact_str = function(n) {
    let outptr = mod.exports.fact_str(n);
    let result = copyCStr(Module, outptr);
    return result;
  };
})
</code></pre>

<p>
  The compiled WebAssembly code is reasonably short. Try to understand what's happening!
</p>

<pre><code class="c">(func $fact (param i32) (result i64)
  (local i64 i64)
  block  ;; label = @1
    block  ;; label = @2
      get_local 0
      i32.eqz
      br_if 0 (;@2;)
      get_local 0
      i64.extend_u/i32
      set_local 1
      i64.const 1
      set_local 2
      loop  ;; label = @3
        get_local 1
        get_local 2
        i64.mul
        set_local 2
        get_local 1
        i64.const -1
        i64.add
        tee_local 1
        i64.eqz
        i32.eqz
        br_if 0 (;@3;)
        br 2 (;@1;)
      end
      unreachable
    end
    i64.const 1
    set_local 2
  end
  get_local 2)
</code></pre>

      </div>
    </div>

    <footer>
  <hr>
  <p>
      This is not an official <a href="https://www.rust-lang.org/">Rust</a> project /
      <a href="/info/">Info</a> / 
      <a href="https://github.com/badboy/hellorust">Contribute</a> /
      <a href="/feed.xml">RSS Feed</a>
  </p>
</footer>

    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
